{% extends 'base.html' %}

{% block content %}

<body class="is-preload">

    <div class="pull-right" style="margin-top: 15px;">
        {% if revision %}
        <a href="{% url 'editrevision' project.id assembly.id part.id revision.id %}" class="btn btn-success btn-small">
            <i class="icon-white icon-cog"></i> Edit Revision
        </a>
        <a href="{% url 'newrevision' project.id assembly.id part.id %}" class="btn btn-primary btn-small">
            <i class="icon-white icon-plus"></i> New Revision
        </a>
        {% if can_delete_revisions and revisions|length > 1 %}
        <a href="#" onclick="confirmDeleteRevision()" class="btn btn-danger btn-small">
            <i class="icon-white icon-trash"></i> Delete Revision
        </a>
        {% endif %}
        {% else %}
        <a href="edit" class="btn btn-success btn-small">
            <i class="icon-white icon-cog"></i> Edit Part
        </a>
        {% endif %}
    </div>
    <h2>{{ part.name }} - Details</h2>
    
    {% if revisions %}
    <div class="revision-selector" style="margin-bottom: 20px;">
        <label for="revision-select"><strong>Revision:</strong></label>
        <select id="revision-select" onchange="changeRevision()">
            {% for rev in revisions %}
            <option value="{% url 'part_revision' project.id assembly.id part.id rev.id %}" 
                    {% if revision and rev.id == revision.id %}selected{% elif not revision and forloop.first %}selected{% endif %}>
                Rev {{ rev.revision_number }} - {{ rev.get_status_display }}
            </option>
            {% endfor %}
        </select>
    </div>
    {% endif %}

    <div>
        <a href="/projects/{{ project.id }}"><b>{{ project.name }}</b></a>
        {% if part.assembly %}
        <i class="icon-chevron-right"></i> {{ part.assembly }}
        {% endif %}
        <i class="icon-chevron-right"></i> <b>{{ part.name }}</b>
    </div>
    <br />

    <div class="row" style="margin: 0;">
        <div class="col-md-6" style="padding-right: 15px;">
            <table class="table table-striped table-condensed table-bordered" style="width: auto;">
                <tr>
                  <td><b>Project</b></td>
                  <td><a href="/projects/{{ project.id }}">{{ project.name }}</a></td>
                </tr>
                <tr><td><b>Part Number</b></td><td>{{ part.part_number }}</td></tr>
                {% if revision %}
                <tr><td><b>Revision</b></td><td>{{ revision.revision_number }}</td></tr>
                <tr>
                  <td><b>Status</b></td>
                  <td>
                    <span class="label label-status-{{ revision.status }}">{{ revision.get_status_display }}</span>
                  </td>
                </tr>
                <tr>
                  <td><b>Assignee</b></td>
                  <td>{{ revision.owner|default:"Unassigned" }}</td>
                </tr>
                <tr><td><b>Source material</b></td><td>{{ revision.material|default:"Not specified" }}</td></tr>
                <tr><td><b>Quantity required</b></td><td>{{ revision.quantity|default:"Not specified" }}</td></tr>
                <tr><td><b>Manufacturing method</b></td><td>{{ revision.get_mfg_type_display|default:"Not specified" }}</td></tr>
                <tr><td><b>Drawing</b></td><td>
                    {% if revision.drawing %}
                        <a href="{{ revision.drawing.url }}" target="_blank">Download</a>
                    {% else %}
                        No drawing
                    {% endif %}
                </td></tr>
                <tr><td><b>Created</b></td><td>{{ revision.created_at|date:"M d, Y H:i" }}</td></tr>
                <tr><td><b>Updated</b></td><td>{{ revision.updated_at|date:"M d, Y H:i" }}</td></tr>
                {% if revision.notes %}
                <tr><td><b>Notes</b></td><td>{{ revision.notes }}</td></tr>
                {% endif %}
                {% else %}
                <tr><td><b>Status</b></td><td>No revisions available</td></tr>
                {% endif %}
              </table>
        </div>
        
        <div class="col-md-6" style="padding-left: 15px;">
            {% if revision and revision.drawing %}
            <div class="drawing-preview-panel">
                <h4>Drawing Preview</h4>
                <div id="previewContainer" style="width: 100%; height: 500px; position: relative; border: 1px solid #ddd; border-radius: 4px;">
                    <div id="loadingSpinner" class="text-center" style="padding: 50px;">
                        <i class="icon-spinner icon-spin"></i> Loading preview...
                    </div>
                    <div id="previewContent" style="display: none;">
                        <!-- 3D Viewer Container -->
                        <div id="threejs-container" style="width: 100%; height: 100%; display: none;"></div>
                        <!-- 2D Image/PDF Container -->
                        <div id="image-container" style="width: 100%; height: 100%; display: none; text-align: center;">
                            <img id="preview-image" style="max-width: 100%; max-height: 100%; object-fit: contain;" />
                        </div>
                        <!-- PDF Container -->
                        <div id="pdf-container" style="width: 100%; height: 100%; display: none;">
                            <iframe id="pdf-viewer" style="width: 100%; height: 100%; border: none;"></iframe>
                        </div>
                    </div>
                    <div id="previewError" style="display: none; text-align: center; padding: 50px; color: #d9534f;">
                        <i class="icon-exclamation-sign"></i> Preview not available for this file type
                    </div>
                </div>
                <div style="margin-top: 10px;">
                    <a href="{{ revision.drawing.url }}" target="_blank" class="btn btn-primary btn-sm">
                        <i class="icon-download"></i> Download Original
                    </a>
                </div>
            </div>
            {% else %}
            <div class="drawing-preview-panel">
                <h4>Drawing Preview</h4>
                <div style="width: 100%; height: 500px; border: 1px solid #ddd; border-radius: 4px; display: flex; align-items: center; justify-content: center; background-color: #f9f9f9;">
                    <p class="text-muted">No drawing available</p>
                </div>
            </div>
            {% endif %}
        </div>
    </div>


    <script>
    function changeRevision() {
        var select = document.getElementById('revision-select');
        var url = select.value;
        window.location.href = url;
    }
    
    function confirmDeleteRevision() {
        if (confirm('Are you sure you want to delete this revision? This action cannot be undone.')) {
            window.location.href = "{% url 'deleterevision' project.id assembly.id part.id revision.id %}";
        }
    }

    // Auto-load drawing preview when page loads
    {% if revision and revision.drawing %}
    document.addEventListener('DOMContentLoaded', function() {
        console.log('Loading preview for:', '{{ revision.drawing.name }}');
        
        // Add a small delay to ensure container is properly sized
        setTimeout(function() {
            loadPreview('{{ revision.drawing.url }}', '{{ revision.drawing.name }}');
        }, 100);
        
        // Add a timeout to show something if preview fails
        setTimeout(function() {
            const loadingSpinner = document.getElementById('loadingSpinner');
            if (loadingSpinner && loadingSpinner.style.display !== 'none') {
                console.log('Preview loading timeout - showing fallback');
                showPreviewError();
            }
        }, 10000); // 10 second timeout
    });
    {% endif %}

    function loadPreview(fileUrl, fileName) {
        console.log('loadPreview called with:', fileUrl, fileName);
        
        const loadingSpinner = document.getElementById('loadingSpinner');
        const previewContent = document.getElementById('previewContent');
        const previewError = document.getElementById('previewError');
        const threejsContainer = document.getElementById('threejs-container');
        const imageContainer = document.getElementById('image-container');
        const pdfContainer = document.getElementById('pdf-container');

        console.log('Elements found:', {
            loadingSpinner: !!loadingSpinner,
            previewContent: !!previewContent,
            previewError: !!previewError,
            threejsContainer: !!threejsContainer,
            imageContainer: !!imageContainer,
            pdfContainer: !!pdfContainer
        });

        // Reset display
        if (loadingSpinner) loadingSpinner.style.display = 'block';
        if (previewContent) previewContent.style.display = 'none';
        if (previewError) previewError.style.display = 'none';
        if (threejsContainer) threejsContainer.style.display = 'none';
        if (imageContainer) imageContainer.style.display = 'none';
        if (pdfContainer) pdfContainer.style.display = 'none';

        // Get file extension
        const fileExtension = fileName.split('.').pop().toLowerCase();
        console.log('File extension:', fileExtension);
        
        // Determine preview type and load accordingly
        if (['stl', 'step', 'stp', 'iges', 'dxf'].includes(fileExtension)) {
            console.log('Loading 3D preview for:', fileExtension);
            load3DPreview(fileUrl, fileExtension);
        } else if (['pdf'].includes(fileExtension)) {
            console.log('Loading PDF preview');
            loadPDFPreview(fileUrl);
        } else if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff'].includes(fileExtension)) {
            console.log('Loading image preview');
            loadImagePreview(fileUrl);
        } else if (['dwg'].includes(fileExtension)) {
            console.log('Loading DWG placeholder');
            showDWGPlaceholder(fileUrl);
        } else {
            console.log('Showing preview error for unsupported type');
            showPreviewError();
        }
    }

    function createPlaceholderGeometry(scene, fileType, color) {
        // Create a placeholder geometry with text
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshLambertMaterial({ color: color });
        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);
        
        // Add text indicating the file type
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 64;
        context.fillStyle = '#000000';
        context.font = '16px Arial';
        context.fillText(fileType + ' Preview', 10, 35);
        
        const texture = new THREE.CanvasTexture(canvas);
        const textMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        const textGeometry = new THREE.PlaneGeometry(2, 0.5);
        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
        textMesh.position.set(0, 0, 0.6);
        scene.add(textMesh);
        
        // Show the preview
        const loadingSpinner = document.getElementById('loadingSpinner');
        const previewContent = document.getElementById('previewContent');
        const threejsContainer = document.getElementById('threejs-container');
        
        loadingSpinner.style.display = 'none';
        previewContent.style.display = 'block';
        threejsContainer.style.display = 'block';
    }

    function showDWGPlaceholder(fileUrl) {
        const loadingSpinner = document.getElementById('loadingSpinner');
        const previewContent = document.getElementById('previewContent');
        const imageContainer = document.getElementById('image-container');
        
        // Create a placeholder for DWG files
        const placeholderDiv = document.createElement('div');
        placeholderDiv.style.cssText = 'width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px; padding: 20px; text-align: center;';
        
        const iconDiv = document.createElement('div');
        iconDiv.style.cssText = 'font-size: 64px; margin-bottom: 20px; opacity: 0.9;';
        iconDiv.innerHTML = '🏗️';
        
        const titleDiv = document.createElement('div');
        titleDiv.style.cssText = 'font-size: 24px; font-weight: bold; margin-bottom: 12px;';
        titleDiv.textContent = 'DWG File';
        
        const descDiv = document.createElement('div');
        descDiv.style.cssText = 'font-size: 16px; margin-bottom: 20px; opacity: 0.9; line-height: 1.4;';
        descDiv.innerHTML = 'DWG files require AutoCAD or compatible software.<br/>Try converting to DXF for web preview.';
        
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = 'display: flex; gap: 12px; flex-wrap: wrap; justify-content: center;';
        
        const downloadBtn = document.createElement('a');
        downloadBtn.href = fileUrl;
        downloadBtn.target = '_blank';
        downloadBtn.className = 'btn btn-light btn-sm';
        downloadBtn.style.cssText = 'color: #667eea; font-weight: bold;';
        downloadBtn.innerHTML = '<i class="icon-download"></i> Download DWG';
        
        const convertBtn = document.createElement('button');
        convertBtn.className = 'btn btn-outline-light btn-sm';
        convertBtn.style.cssText = 'border: 2px solid white; color: white; font-weight: bold;';
        convertBtn.innerHTML = '<i class="icon-refresh"></i> Convert to DXF';
        convertBtn.onclick = () => showConversionInfo();
        
        buttonContainer.appendChild(downloadBtn);
        buttonContainer.appendChild(convertBtn);
        
        placeholderDiv.appendChild(iconDiv);
        placeholderDiv.appendChild(titleDiv);
        placeholderDiv.appendChild(descDiv);
        placeholderDiv.appendChild(buttonContainer);
        
        imageContainer.innerHTML = '';
        imageContainer.appendChild(placeholderDiv);
        
        loadingSpinner.style.display = 'none';
        previewContent.style.display = 'block';
        imageContainer.style.display = 'block';
    }

    function showConversionInfo() {
        alert('To convert DWG to DXF:\n\n' +
              '1. Open the DWG file in AutoCAD\n' +
              '2. Go to File > Save As\n' +
              '3. Change file type to "AutoCAD DXF (*.dxf)"\n' +
              '4. Save and upload the DXF file for web preview\n\n' +
              'Alternatively, use online converters like:\n' +
              '• Convertio.co\n' +
              '• CloudConvert.com\n' +
              '• Zamzar.com');
    }

    function load3DPreview(fileUrl, fileExtension) {
        console.log('load3DPreview called with:', fileUrl, fileExtension);
        
        // Load Three.js and STLLoader dynamically
        if (!window.THREE) {
            console.log('THREE.js not loaded, loading it now...');
            const threeScript = document.createElement('script');
            threeScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
            threeScript.onload = () => {
                console.log('THREE.js loaded successfully');
                loadSTLLoader(fileUrl, fileExtension);
            };
            threeScript.onerror = (error) => {
                console.error('Failed to load THREE.js:', error);
                showPreviewError();
            };
            document.head.appendChild(threeScript);
        } else {
            console.log('THREE.js already loaded');
            loadSTLLoader(fileUrl, fileExtension);
        }
    }

    function loadSTLLoader(fileUrl, fileExtension) {
        console.log('loadSTLLoader called with:', fileUrl, fileExtension);
        
        // Load STLLoader for STL files
        if (fileExtension === 'stl' && !window.STLLoader) {
            console.log('STLLoader not available, loading it now...');
            const stlScript = document.createElement('script');
            stlScript.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js';
            stlScript.onload = () => {
                console.log('STLLoader loaded successfully');
                init3DViewer(fileUrl, fileExtension);
            };
            stlScript.onerror = (error) => {
                console.error('Failed to load STLLoader:', error);
                console.log('Falling back to placeholder geometry');
                init3DViewer(fileUrl, fileExtension);
            };
            document.head.appendChild(stlScript);
        } else if (fileExtension === 'dxf') {
            console.log('Loading DXF with custom parser');
            loadDXFAlternative(fileUrl);
        } else {
            console.log('Initializing 3D viewer directly');
            init3DViewer(fileUrl, fileExtension);
        }
    }


    function loadDXFAlternative(fileUrl) {
        // Alternative DXF handling - try to parse basic DXF content
        fetch(fileUrl)
            .then(response => response.text())
            .then(dxfContent => {
                try {
                    initBasicDXFViewer(dxfContent);
                } catch (error) {
                    console.error('Error parsing DXF:', error);
                    init3DViewer(fileUrl, 'dxf');
                }
            })
            .catch(error => {
                console.error('Error loading DXF file:', error);
                init3DViewer(fileUrl, 'dxf');
            });
    }

    function initBasicDXFViewer(dxfContent) {
        const container = document.getElementById('threejs-container');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const previewContent = document.getElementById('previewContent');
        const threejsContainer = document.getElementById('threejs-container');

        // Clear previous content
        while (container.firstChild) {
            container.removeChild(container.firstChild);
        }

        // Create a basic Three.js scene for DXF
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, container.offsetWidth / container.offsetHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(container.offsetWidth, container.offsetHeight);
        renderer.setClearColor(0xf0f0f0);
        container.appendChild(renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Parse DXF content and create geometry
        try {
            const lines = dxfContent.split('\n');
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            let lineCount = 0;

            console.log('Parsing DXF file with', lines.length, 'lines');

            // Enhanced DXF parsing for multiple entity types
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line === 'LINE') {
                    // Parse LINE entities
                    let x1 = 0, y1 = 0, z1 = 0, x2 = 0, y2 = 0, z2 = 0;
                    for (let j = i + 1; j < Math.min(i + 20, lines.length); j++) {
                        const code = lines[j].trim();
                        const value = lines[j + 1] ? parseFloat(lines[j + 1]) : 0;
                        if (code === '10') x1 = value;
                        else if (code === '20') y1 = value;
                        else if (code === '30') z1 = value;
                        else if (code === '11') x2 = value;
                        else if (code === '21') y2 = value;
                        else if (code === '31') z2 = value;
                    }
                    
                    if (x1 !== 0 || y1 !== 0 || z1 !== 0 || x2 !== 0 || y2 !== 0 || z2 !== 0) {
                        vertices.push(x1, y1, z1, x2, y2, z2);
                        colors.push(0, 0, 0, 0, 0, 0); // Black lines
                        lineCount++;
                    }
                } else if (line === 'CIRCLE') {
                    // Parse CIRCLE entities
                    let cx = 0, cy = 0, cz = 0, radius = 0;
                    for (let j = i + 1; j < Math.min(i + 20, lines.length); j++) {
                        const code = lines[j].trim();
                        const value = lines[j + 1] ? parseFloat(lines[j + 1]) : 0;
                        if (code === '10') cx = value;
                        else if (code === '20') cy = value;
                        else if (code === '30') cz = value;
                        else if (code === '40') radius = value;
                    }
                    
                    if (radius > 0) {
                        // Create circle using line segments
                        const segments = 32;
                        for (let s = 0; s < segments; s++) {
                            const angle1 = (s / segments) * Math.PI * 2;
                            const angle2 = ((s + 1) / segments) * Math.PI * 2;
                            
                            const x1 = cx + Math.cos(angle1) * radius;
                            const y1 = cy + Math.sin(angle1) * radius;
                            const x2 = cx + Math.cos(angle2) * radius;
                            const y2 = cy + Math.sin(angle2) * radius;
                            
                            vertices.push(x1, y1, cz, x2, y2, cz);
                            colors.push(0, 0, 0, 0, 0, 0);
                        }
                        lineCount++;
                    }
                } else if (line === 'ARC') {
                    // Parse ARC entities
                    let cx = 0, cy = 0, cz = 0, radius = 0, startAngle = 0, endAngle = 0;
                    for (let j = i + 1; j < Math.min(i + 30, lines.length); j++) {
                        const code = lines[j].trim();
                        const value = lines[j + 1] ? parseFloat(lines[j + 1]) : 0;
                        if (code === '10') cx = value;
                        else if (code === '20') cy = value;
                        else if (code === '30') cz = value;
                        else if (code === '40') radius = value;
                        else if (code === '50') startAngle = value * Math.PI / 180; // Convert to radians
                        else if (code === '51') endAngle = value * Math.PI / 180;
                    }
                    
                    if (radius > 0) {
                        // Create arc using line segments
                        const segments = Math.max(16, Math.abs(endAngle - startAngle) * 16 / Math.PI);
                        for (let s = 0; s < segments; s++) {
                            const angle1 = startAngle + (s / segments) * (endAngle - startAngle);
                            const angle2 = startAngle + ((s + 1) / segments) * (endAngle - startAngle);
                            
                            const x1 = cx + Math.cos(angle1) * radius;
                            const y1 = cy + Math.sin(angle1) * radius;
                            const x2 = cx + Math.cos(angle2) * radius;
                            const y2 = cy + Math.sin(angle2) * radius;
                            
                            vertices.push(x1, y1, cz, x2, y2, cz);
                            colors.push(0, 0, 0, 0, 0, 0);
                        }
                        lineCount++;
                    }
                }
            }

            console.log('Found', lineCount, 'entities in DXF file');

            if (vertices.length > 0) {
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const material = new THREE.LineBasicMaterial({ 
                    vertexColors: true,
                    linewidth: 1
                });
                const linesMesh = new THREE.LineSegments(geometry, material);
                scene.add(linesMesh);
                
                console.log('Successfully rendered DXF with', vertices.length / 6, 'line segments');
            } else {
                console.log('No geometry found in DXF, showing placeholder');
                createPlaceholderGeometry(scene, 'DXF', 0xff6600);
            }
        } catch (error) {
            console.error('Error parsing DXF:', error);
            createPlaceholderGeometry(scene, 'DXF', 0xff6600);
        }

        camera.position.z = 5;

        // Add controls for rotation
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;

        container.addEventListener('mousedown', (event) => {
            isMouseDown = true;
        });

        container.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        container.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                mouseX = (event.clientX / container.offsetWidth) * 2 - 1;
                mouseY = -(event.clientY / container.offsetHeight) * 2 + 1;
                
                // Rotate the scene
                scene.rotation.y = mouseX * Math.PI;
                scene.rotation.x = mouseY * Math.PI;
            }
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Store scene reference for cleanup
        window.scene = scene;

        // Show the preview
        loadingSpinner.style.display = 'none';
        previewContent.style.display = 'block';
        threejsContainer.style.display = 'block';
    }


    function init3DViewer(fileUrl, fileExtension) {
        console.log('init3DViewer called with:', fileUrl, fileExtension);
        
        const container = document.getElementById('threejs-container');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const previewContent = document.getElementById('previewContent');

        console.log('3D viewer elements:', {
            container: !!container,
            loadingSpinner: !!loadingSpinner,
            previewContent: !!previewContent,
            containerSize: container ? { width: container.offsetWidth, height: container.offsetHeight } : 'N/A'
        });

        // Clear previous scene
        while (container.firstChild) {
            container.removeChild(container.firstChild);
        }

        // Create scene
        const scene = new THREE.Scene();
        const containerWidth = container.offsetWidth || 400;
        const containerHeight = container.offsetHeight || 400;
        const camera = new THREE.PerspectiveCamera(75, containerWidth / containerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        console.log('Three.js objects created:', { scene, camera, renderer });
        
        console.log('Setting renderer size to:', containerWidth, 'x', containerHeight);
        
        renderer.setSize(containerWidth, containerHeight);
        renderer.setClearColor(0xf0f0f0);
        container.appendChild(renderer.domElement);
        
        // Update camera aspect ratio
        camera.aspect = containerWidth / containerHeight;
        camera.updateProjectionMatrix();

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Handle different 3D file types
        if (fileExtension === 'stl') {
            console.log('Processing STL file:', fileUrl);
            console.log('STLLoader available check:', !!window.STLLoader, 'THREE.STLLoader:', !!THREE.STLLoader);
            // Load actual STL file
            if (window.STLLoader || THREE.STLLoader) {
                console.log('STLLoader is available, loading STL file...');
                const loader = new THREE.STLLoader();
                loader.load(fileUrl, function(geometry) {
                    console.log('STL file loaded successfully, geometry:', geometry);
                    const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    // Center and scale the model
                    geometry.computeBoundingBox();
                    const boundingBox = geometry.boundingBox;
                    const center = boundingBox.getCenter(new THREE.Vector3());
                    const size = boundingBox.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 2 / maxDim;
                    
                    console.log('STL bounding box:', { center, size, maxDim, scale });
                    
                    mesh.scale.setScalar(scale);
                    mesh.position.sub(center.multiplyScalar(scale));
                    
                    scene.add(mesh);
                    console.log('STL mesh added to scene');
                    
                    // Show the preview
                    loadingSpinner.style.display = 'none';
                    previewContent.style.display = 'block';
                    threejsContainer.style.display = 'block';
                    console.log('STL preview displayed');
                }, function(progress) {
                    // Loading progress
                    console.log('STL loading progress:', (progress.loaded / progress.total * 100) + '%');
                }, function(error) {
                    console.error('STL loading error:', error);
                    showPreviewError();
                });
            } else {
                console.log('STLLoader not available, showing placeholder');
                // Fallback if STLLoader not available
                createPlaceholderGeometry(scene, 'STL', 0x00ff00);
            }
        } else if (fileExtension === 'dxf') {
            // DXF files - this should be handled by DXF viewer, but fallback to placeholder
            createPlaceholderGeometry(scene, 'DXF', 0xff6600);
        } else if (['step', 'stp', 'iges'].includes(fileExtension)) {
            // Other 3D formats - show placeholder
            createPlaceholderGeometry(scene, fileExtension.toUpperCase(), 0x0066cc);
        } else {
            // Default placeholder
            createPlaceholderGeometry(scene, '3D', 0x666666);
        }

        camera.position.z = 3;

        // Add controls for rotation
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;

        container.addEventListener('mousedown', (event) => {
            isMouseDown = true;
        });

        container.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        container.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                mouseX = (event.clientX / container.offsetWidth) * 2 - 1;
                mouseY = -(event.clientY / container.offsetHeight) * 2 + 1;
                
                // Rotate the first mesh in the scene
                if (scene.children.length > 0) {
                    const mesh = scene.children.find(child => child instanceof THREE.Mesh);
                    if (mesh) {
                        mesh.rotation.y = mouseX * Math.PI;
                        mesh.rotation.x = mouseY * Math.PI;
                    }
                }
            }
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Store scene reference for cleanup
        window.scene = scene;

        // For non-STL files, show the preview immediately
        if (fileExtension !== 'stl') {
            // Show the preview
            loadingSpinner.style.display = 'none';
            previewContent.style.display = 'block';
            threejsContainer.style.display = 'block';
        }
    }

    function loadPDFPreview(fileUrl) {
        const loadingSpinner = document.getElementById('loadingSpinner');
        const previewContent = document.getElementById('previewContent');
        const pdfContainer = document.getElementById('pdf-container');
        const pdfViewer = document.getElementById('pdf-viewer');

        // Use Google Docs viewer for PDF preview
        pdfViewer.src = 'https://docs.google.com/gview?url=' + encodeURIComponent(fileUrl) + '&embedded=true';
        
        loadingSpinner.style.display = 'none';
        previewContent.style.display = 'block';
        pdfContainer.style.display = 'block';
    }

    function loadImagePreview(fileUrl) {
        console.log('loadImagePreview called with:', fileUrl);
        
        const loadingSpinner = document.getElementById('loadingSpinner');
        const previewContent = document.getElementById('previewContent');
        const imageContainer = document.getElementById('image-container');
        const previewImage = document.getElementById('preview-image');

        console.log('Image preview elements:', {
            loadingSpinner: !!loadingSpinner,
            previewContent: !!previewContent,
            imageContainer: !!imageContainer,
            previewImage: !!previewImage
        });

        if (!previewImage) {
            console.error('preview-image element not found');
            showPreviewError();
            return;
        }

        previewImage.src = fileUrl;
        previewImage.onload = function() {
            console.log('Image loaded successfully');
            if (loadingSpinner) loadingSpinner.style.display = 'none';
            if (previewContent) previewContent.style.display = 'block';
            if (imageContainer) imageContainer.style.display = 'block';
        };
        previewImage.onerror = function(error) {
            console.error('Image failed to load:', error);
            showPreviewError();
        };
    }

    function showPreviewError() {
        console.log('showPreviewError called');
        
        const loadingSpinner = document.getElementById('loadingSpinner');
        const previewError = document.getElementById('previewError');
        
        console.log('Error elements:', {
            loadingSpinner: !!loadingSpinner,
            previewError: !!previewError
        });
        
        if (loadingSpinner) loadingSpinner.style.display = 'none';
        if (previewError) previewError.style.display = 'block';
    }

    </script>

    {% endblock content %}